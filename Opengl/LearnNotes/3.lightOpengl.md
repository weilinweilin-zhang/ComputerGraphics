- [向量与vec3关系](#向量与vec3关系)
- [向量乘法](#向量乘法)
- [光照](#光照)
  - [颜色](#颜色)
    - [一个着色器的生命周期](#一个着色器的生命周期)
    - [光照颜色](#光照颜色)
    - [phong 模型](#phong-模型)
      - [环境光照](#环境光照)
      - [漫反射光照](#漫反射光照)
        - [计算漫反射光照：(有疑问的点)](#计算漫反射光照有疑问的点)
      - [镜面光照](#镜面光照)
  - [向量点乘](#向量点乘)
    - [矩阵乘法](#矩阵乘法)
    - [使用 C++ 和 GLM 库的示例](#使用-c-和-glm-库的示例)
    - [代码解析](#代码解析)

# 向量与vec3关系
![alt text](image-38.png)

# 向量乘法
![alt text](image-39.png)
把向量点乘转化 转置乘向量，转化为矩阵乘法。 两个结果相等

# 光照
## 颜色
### 一个着色器的生命周期
因为里面调用函数都直接拿gpu里面的数据，当有多个着色器的时候，怎么分别资源管理的呢

想必使用的时候，就用这个进行切换的吧
![ ](image-28.png)
回答:
``` 
glUseProgram 是不是把当前gpu资源切换成当前的着色器program，然后就可以调用不同着色器内部的参数
是的，`glUseProgram` 函数在OpenGL中确实起到了切换当前使用的着色器程序的作用。当你调用 `glUseProgram` 时，它会将指定的着色器程序设为当前活动的程序。从该调用开始，到下一个调用 `glUseProgram` 之前，所有的渲染调用将使用这个着色器程序。
一旦一个着色器程序被设置为当前活动程序，你就可以使用 OpenGL 提供的函数来设置这个程序中的uniform变量等参数。这包括但不限于：
- `glUniform1f`, `glUniform2f`, `glUniform3f`, `glUniform4f` 等，用于设置浮点类型的uniform变量。
- `glUniform1i`, `glUniform2i`, `glUniform3i`, `glUniform4i` 等，用于设置整数类型的uniform变量。
- `glUniformMatrix2fv`, `glUniformMatrix3fv`, `glUniformMatrix4fv` 等，用于设置矩阵类型的uniform变量。
- `glBindAttribLocation` 和 `glGetAttribLocation` 用于设置和获取attribute的位置。
```

### 光照颜色
也就是 光照的颜色，乘以当前物体的颜色，就是混合起来，并且作用于当前的物体就是结果色，但是后续应该还要考虑距离的问题
```
glm::vec3 lightColor(1.0f, 1.0f, 1.0f);
glm::vec3 toyColor(1.0f, 0.5f, 0.31f);
glm::vec3 result = lightColor * toyColor; // = (1.0f, 0.5f, 0.31f);
```

### phong 模型
phong 模型 包括环境光照，漫反射光照，镜面光照
#### 环境光照
Ambient Lighting)：即使在黑暗的情况下，世界上通常也仍然有一些光亮（月亮、远处的光），所以物体几乎永远不会是完全黑暗的。为了模拟这个，我们会使用一个环境光照常量，它永远会给物体一些颜色。
像代码里面直接就乘以一个外面的颜色值，就类似全局照明模型了。
（真正的全局照明算法 比较复杂 考虑到这种情况的算法叫做全局照明(Global Illumination)算法，但是这种算法既开销高昂又极其复杂。）

#### 漫反射光照
(Diffuse Lighting)：模拟光源对物体的方向性影响(Directional Impact)。它是风氏光照模型中视觉上最显著的分量。物体的某一部分越是正对着光源，它就会越亮
![alt text](image-29.png)

这个是入光的向量，和反射的向量呈现余弦值，所以两向量垂直的时候是没有光线的，两向量角度为0的时候，亮度最亮

漫反射的条件：
```
计算漫反射光照需要什么？
法向量：一个垂直于顶点表面的向量。
定向的光线：作为光源的位置与片段的位置之间向量差的方向向量。为了计算这个光线，我们需要光的位置向量和片段的位置向量。
```

##### 计算漫反射光照：(有疑问的点)
正常来说，在片段着色器里面只要颜色或者纹理就行，为什么在计算漫反射光照的时候要在片段着色器里面计算 这个model的坐标然后乘上这个片段着色器呢
![alt text](image-30.png)
![alt text](image-31.png)
估计的原因就是根据法向量，然后决定着fragment 片段着色器的 显示的分量，就是光照的亮度，然后不同颜色估计得，向量相乘（不是点×乘）就是计算分量，然后得出具体显示的颜色


法线计算，它直接在输入顶点的时候就把简单的法向量，直接输入进去了。
然后跟随着模式矩阵 旋转 位移等操作。
![alt text](image-32.png)


在顶点着色器里面获取 模型矩阵进行计算，为了在片段着色器 配合着法向量计算 光线的偏角度
![alt text](image-33.png)

* 步骤
```
 外部要传入 光源的位置，然后以及颜色,然后计算向量角度

光源坐标，怎么来的，怎么兼容他的旋转 （目前就写死一个向量坐标）

光源向量，就是光线位置减去当前顶点坐标的位置，然后点乘该顶点的法向量，计算出光照分量，

光照分量在加上环境光照 ，在成该点的颜色值，即可得出该点的最终颜色

光线向量和法向量 越向90趋势，那么光照越弱 因为cos 90 等于0

如果不乘上环境光的话，那么cos 大于90哪些光线分量就是黑色的，环境光线给点 颜色值而已
```
![alt text](image-34.png)

没有环境光线就是漆黑的一片
![alt text](image-35.png)
有环境光分量就更亮点
![alt text](image-36.png)

法向量在 modelview矩阵改变的时候 发生不等比的scale时候，法向量，会变，等比时发现法向量可能长度有变但是方向不变，使用归一化能简单解决这个问题。

不等比scale要怎么处理呢


法向量不是跟切线一样代表着通过两个点进行计算,它是定义为 垂直的切线的，所以他不能通过两个点去乘上这个modelview矩阵计算法向量。
![alt text](image-37.png)

但是我们知道这个切线向量，是通过两个点去计算的，这两个点是受这个modelview矩阵影响，所以我们可以得到这个切线转换后的向量，然后通过垂直可以得出 切线向量和法向量点乘 为0 ，既可求出法向量。

emm 他们好像是用法线矩阵
使用一个矩阵来达到算出法向量的效果。
Consider a 3×3 matrix G, and lets see how this matrix could be computed to properly transform the normal vectors



// 法线矩阵被定义为法线矩阵被定义为「模型矩阵左上角3x3部分的逆矩阵的转置矩阵」 
```
推的话 在这里http://www.lighthouse3d.com/tutorials/glsl-12-tutorial/the-normal-matrix/
通过垂直点乘为0去计算得到矩阵。
结果是
Normal = mat3(transpose(inverse(model))) * aNormal;
```
注意点是：
gpu不太擅长难度大的操作。
矩阵求逆是一项对于着色器开销很大的运算，因为它必须在场景中的每一个顶点上进行，所以应该尽可能地避免在着色器中进行求逆运算。以学习为目的的话这样做还好，但是对于一个高效的应用来说，你最好先在CPU上计算出法线矩阵，再通过uniform把它传递给着色器（就像模型矩阵一样）。
在漫反射光照部分，光照表现并没有问题，这是因为我们没有对物体进行任何缩放操作，所以我们并不真的需要使用一个法线矩阵，而是仅以模型矩阵乘以法线就可以。但是如果你会进行不等比缩放，使用法线矩阵去乘以法向量就是必须的了。

正交矩阵 每一行每一列 每个数平均加起来为1 ,正交矩阵的逆 等于转置矩阵
#### 镜面光照
Specular Lighting)：模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。

向量点乘（内积）和矩阵乘法在数学上是紧密相关的。具体来说，向量点乘可以视为矩阵乘法的一种特殊情况。通过理解它们之间的关系，我们可以更深入地理解线性代数以及计算机图形学中的一些基本运算。


反射的光线角度和人眼观察之间的夹角，
![alt text](image-40.png)


## 向量点乘
给定两个 \( n \) 维向量 \(\mathbf{a}\) 和 \(\mathbf{b}\)，它们的点积定义为：
\[ 
\mathbf{a} \cdot \mathbf{b} = a_1 b_1 + a_2 b_2 + \cdots + a_n b_n
\]
例如，对于两个三维向量 \(\mathbf{a} = (a_1, a_2, a_3)\) 和 \(\mathbf{b} = (b_1, b_2, b_3)\)，点积为：
\[ 
\mathbf{a} \cdot \mathbf{b} = a_1 b_1 + a_2 b_2 + a_3 b_3 
\]
### 矩阵乘法
矩阵乘法则是更广义的运算。如果我们有一个行向量 \(\mathbf{a}\) 和一个列向量 \(\mathbf{b}\)，它们的乘法可以视为矩阵与向量的乘法。在这种情况下，点积实际上就是矩阵乘法的一种特例。
例如，考虑一个 \(1 	imes n\) 的行向量 \(\mathbf{a}\) 和一个 \(n 	imes 1\) 的列向量 \(\mathbf{b}\)，它们的乘积是一个标量：
\[ 
\mathbf{a} = \begin{pmatrix}
a_1 & a_2 & \cdots & a_n
\end{pmatrix}
\]
\[ 
\mathbf{b} = \begin{pmatrix}
b_1 \\ b_2 \\ \vdots \\ b_n
\end{pmatrix}
\]
\[ 
\mathbf{a} \mathbf{b} = \begin{pmatrix}
a_1 & a_2 & \cdots & a_n
\end{pmatrix}
\begin{pmatrix}
b_1 \\ b_2 \\ \vdots \\ b_n
\end{pmatrix}
= a_1 b_1 + a_2 b_2 + \cdots + a_n b_n
\]
这实际上就是\(\mathbf{a} \cdot \mathbf{b}\)，即这两个向量的点积。
### 使用 C++ 和 GLM 库的示例
为了更好地理解这一点，可以使用GLM库在C++中实现上述运算。
```cpp
#include <glm/glm.hpp>
#include <iostream>
int main() {
    // 定义两个三维向量
    glm::vec3 a(1.0f, 2.0f, 3.0f);
    glm::vec3 b(4.0f, 5.0f, 6.0f);
    // 计算点积
    float dotProduct = glm::dot(a, b);
    std::cout << "Dot product: " << dotProduct << std::endl;
    // 定义一个 1x3 行向量和一个 3x1 列向量
    glm::mat1x3 rowVec(a.x, a.y, a.z);
    glm::mat3x1 colVec(b.x, b.y, b.z);
    // 使用矩阵乘法计算点积
    glm::mat1x1 matProduct = rowVec * colVec;
    std::cout << "Matrix product (dot product): " << matProduct[0][0] << std::endl;
    return 0;
}
```
### 代码解析
1. **定义两个三维向量**：
    ```cpp
    glm::vec3 a(1.0f, 2.0f, 3.0f);
    glm::vec3 b(4.0f, 5.0f, 6.0f);
    ```
2. **计算点积**：
    ```cpp
    float dotProduct = glm::dot(a, b);
    std::cout << "Dot product: " << dotProduct << std::endl;
    ```
3. **定义矩阵表示的行向量和列向量**：
    ```cpp
    glm::mat1x3 rowVec(a.x, a.y, a.z);
    glm::mat3x1 colVec(b.x, b.y, b.z);
    ```
4. **使用矩阵乘法计算点积**：
    ```cpp
    glm::mat1x1 matProduct = rowVec * colVec;
    std::cout << "Matrix product (dot product): " << matProduct[0][0] << std::endl;
    ```
总结
- 点积可以看作是行向量和列向量之间的一种特殊的矩阵乘法。
- 矩阵乘法是更广义的运算，可以处理任意形状的矩阵，而点积是矩阵乘法的一种特例，只处理特定形式的向量。
- 利用GLM库，可以方便地在C++中进行向量和矩阵运算，从而验证理论上的数学运算。


