# 高级opengl功能

## 深度缓冲
### 意义：
且运用了深度缓冲(Depth Buffer)来防止被阻挡的面渲染到其它面的前面。
当深度测试(Depth Testing)被启用的时候，OpenGL会将一个片段的深度值与深度缓冲的内容进行对比。OpenGL会执行一个深度测试，如果这个测试通过了的话，深度缓冲将会更新为新的深度值。如果深度测试失败了，片段将会被丢弃。

深度缓冲区存储的是归一化后的深度值（0到1之间），而Z值是物体在视线方向上的实际深度坐标（可能是任意范围）。通过深度缓冲区和深度测试，图形渲染系统能够正确决定哪些像素应该被显示，以产生正确的视觉效果。

被遮挡的片段会被深度测试给缓冲掉。
### 注意：
现在大部分的GPU都提供一个叫做提前深度测试(Early Depth Testing)的硬件特性。提前深度测试允许深度测试在片段着色器之前运行。只要我们清楚一个片段永远不会是可见的（它在其他物体之后），我们就能提前丢弃这个片段。
片段着色器通常开销都是很大的，所以我们应该尽可能避免运行它们。当使用提前深度测试时，片段着色器的一个限制是你不能写入片段的深度值。如果一个片段着色器对它的深度值进行了写入，提前深度测试是不可能的。OpenGL不能提前知道深度值。

### 通过深度测试
一直通过的话，就是最后面绘制的会盖在之前的物体上面

### codes:
glEnable(GL_DEPTH_TEST); 开启深度测试 通过z值来判断

### 深度值精度：
#### 线性深度(一般考虑投影是不会使用的)
思想也是占比大小
![alt text](image-61.png)
#### 非线性
![](image-62.png)
![alt text](image-63.png)
小部分的z值 决定了大部分深度值  这个也是 思想也是反着的占用比例， 
解析：https://www.songho.ca/opengl/gl_projectionmatrix.html


0-1 深度转化NDC 过程
#### ****!!!!!!!理解：
就是两个物体在离近平面 很近的时候， 细微的差异 就能立马分辨出来，然后 着色器就可以丢弃比较后面的片段, 比较远的 差的很远 也可能重叠
比如近平面为0.1 ，然后远平面100 
然后 两个近的 比如 zvalue 1.1 和 1.2 那么他们深度值就可能是 0.20 和 0.28 区别
然后 zvalue 90 和 100的  深度值可能就是  0.994 和 1 的区别，后者虽然 zvalue差别10 然后 深度值 差特别的小，然后距离近平面越近 越能防止深度缓冲的冲突
所以所以，距离近平面比较近的  片段，在摄像机拉远的时候，就变化比较快，很远的 拉动同样的摄像机的距离 大小变化幅度比较的小 

```
#version 330 core
out vec4 FragColor;

float near = 0.1; 
float far  = 100.0; 

float LinearizeDepth(float depth) 
{
    float z = depth * 2.0 - 1.0; // back to NDC 
    return (2.0 * near * far) / (far + near - z * (far - near));    
}

void main()
{             
    float depth = LinearizeDepth(gl_FragCoord.z) / far; // 为了演示除以 far 不然0，1这个范围有点小一下子就全白了，除以far更好的演示
    FragColor = vec4(vec3(depth), 1.0);
}
```
### 深度冲突
fragment 在同一个深度抢着绘制
### 防止深度冲突
第一个也是最重要的技巧是永远不要把多个物体摆得太靠近，以至于它们的一些三角形会重叠。通过在两个物体之间设置一个用户无法注意到的偏移值，你可以完全避免这两个物体之间的深度冲突。在箱子和地板的例子中，我们可以将箱子沿着正y轴稍微移动一点。箱子位置的这点微小改变将不太可能被注意到，但它能够完全减少深度冲突的发生。然而，这需要对每个物体都手动调整，并且需要进行彻底的测试来保证场景中没有物体会产生深度冲突。

第二个技巧是尽可能将近平面设置远一些。在前面我们提到了精度在靠近近平面时是非常高的，所以如果我们将近平面远离观察者，我们将会对整个平截头体有着更大的精度。然而，将近平面设置太远将会导致近处的物体被裁剪掉，所以这通常需要实验和微调来决定最适合你的场景的近平面距离。

另外一个很好的技巧是牺牲一些性能，使用更高精度的深度缓冲。大部分深度缓冲的精度都是24位的，但现在大部分的显卡都支持32位的深度缓冲，这将会极大地提高精度。所以，牺牲掉一些性能，你就能获得更高精度的深度测试，减少深度冲突。

我们上面讨论的三个技术是最普遍也是很容易实现的抗深度冲突技术了。还有一些更复杂的技术，但它们依然不能完全消除深度冲突。深度冲突是一个常见的问题，但如果你组合使用了上面列举出来的技术，你可能不会再需要处理深度冲突了。




## 模板测试


## FBO framebufferObject 帧缓冲对象

