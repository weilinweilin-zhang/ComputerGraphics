- [高级opengl功能](#高级opengl功能)
  - [深度缓冲](#深度缓冲)
    - [意义：](#意义)
    - [注意：](#注意)
    - [通过深度测试](#通过深度测试)
    - [codes:](#codes)
    - [深度值精度：](#深度值精度)
      - [线性深度(一般考虑投影是不会使用的)](#线性深度一般考虑投影是不会使用的)
      - [非线性](#非线性)
      - [\*\*\*\*!!!!!!!个人理解：](#个人理解)
    - [深度冲突](#深度冲突)
    - [防止深度冲突](#防止深度冲突)
  - [模板测试](#模板测试)
    - [示例代码](#示例代码)
    - [](#)
    - [绘制一轮结束后，然后重置代码意义](#绘制一轮结束后然后重置代码意义)
    - [流程](#流程)
  - [混合 blending](#混合-blending)
    - [blending 函数](#blending-函数)
  - [面剔除](#面剔除)
    - [作用：](#作用)
    - [解释：](#解释)
    - [主要解决：](#主要解决)
    - [实现技巧：](#实现技巧)
    - [实现函数](#实现函数)
  - [FBO framebufferObject 帧缓冲对象](#fbo-framebufferobject-帧缓冲对象)

# 高级opengl功能
## 深度缓冲
### 意义：
且运用了深度缓冲(Depth Buffer)来防止被阻挡的面渲染到其它面的前面。
当深度测试(Depth Testing)被启用的时候，OpenGL会将一个片段的深度值与深度缓冲的内容进行对比。OpenGL会执行一个深度测试，如果这个测试通过了的话，深度缓冲将会更新为新的深度值。如果深度测试失败了，片段将会被丢弃。

深度缓冲区存储的是归一化后的深度值（0到1之间），而Z值是物体在视线方向上的实际深度坐标（可能是任意范围）。通过深度缓冲区和深度测试，图形渲染系统能够正确决定哪些像素应该被显示，以产生正确的视觉效果。

被遮挡的片段会被深度测试给缓冲掉。
### 注意：
现在大部分的GPU都提供一个叫做提前深度测试(Early Depth Testing)的硬件特性。提前深度测试允许深度测试在片段着色器之前运行。只要我们清楚一个片段永远不会是可见的（它在其他物体之后），我们就能提前丢弃这个片段。
片段着色器通常开销都是很大的，所以我们应该尽可能避免运行它们。当使用提前深度测试时，片段着色器的一个限制是你不能写入片段的深度值。如果一个片段着色器对它的深度值进行了写入，提前深度测试是不可能的。OpenGL不能提前知道深度值。

### 通过深度测试
一直通过的话，就是最后面绘制的会盖在之前的物体上面

### codes:
glEnable(GL_DEPTH_TEST); 开启深度测试 通过z值来判断

### 深度值精度：
#### 线性深度(一般考虑投影是不会使用的)
思想也是占比大小
![alt text](image-61.png)
#### 非线性
![](image-62.png)
![alt text](image-63.png)
小部分的z值 决定了大部分深度值  这个也是 思想也是反着的占用比例， 
解析：https://www.songho.ca/opengl/gl_projectionmatrix.html


0-1 深度转化NDC 过程
#### ****!!!!!!!个人理解：
就是两个物体在离近平面 很近的时候， 细微的差异 就能立马分辨出来，然后 着色器就可以丢弃比较后面的片段, 比较远的 差的很远 也可能重叠
比如近平面为0.1 ，然后远平面100 
然后 两个近的 比如 zvalue 1.1 和 1.2 那么他们深度值就可能是 0.20 和 0.28 区别
然后 zvalue 90 和 100的  深度值可能就是  0.994 和 1 的区别，后者虽然 zvalue差别10 然后 深度值 差特别的小，然后距离近平面越近 越能防止深度缓冲的冲突
所以所以，距离近平面比较近的  片段，在摄像机拉远的时候，就变化比较快，很远的 拉动同样的摄像机的距离 大小变化幅度比较的小 

```
#version 330 core
out vec4 FragColor;

float near = 0.1; 
float far  = 100.0; 

float LinearizeDepth(float depth) 
{
    float z = depth * 2.0 - 1.0; // back to NDC 
    return (2.0 * near * far) / (far + near - z * (far - near));    
}

void main()
{             
    float depth = LinearizeDepth(gl_FragCoord.z) / far; // 为了演示除以 far 不然0，1这个范围有点小一下子就全白了，除以far更好的演示
    FragColor = vec4(vec3(depth), 1.0);
}
```
### 深度冲突
fragment 在同一个深度抢着绘制
### 防止深度冲突
第一个也是最重要的技巧是永远不要把多个物体摆得太靠近，以至于它们的一些三角形会重叠。通过在两个物体之间设置一个用户无法注意到的偏移值，你可以完全避免这两个物体之间的深度冲突。在箱子和地板的例子中，我们可以将箱子沿着正y轴稍微移动一点。箱子位置的这点微小改变将不太可能被注意到，但它能够完全减少深度冲突的发生。然而，这需要对每个物体都手动调整，并且需要进行彻底的测试来保证场景中没有物体会产生深度冲突。

第二个技巧是尽可能将近平面设置远一些。在前面我们提到了精度在靠近近平面时是非常高的，所以如果我们将近平面远离观察者，我们将会对整个平截头体有着更大的精度。然而，将近平面设置太远将会导致近处的物体被裁剪掉，所以这通常需要实验和微调来决定最适合你的场景的近平面距离。

另外一个很好的技巧是牺牲一些性能，使用更高精度的深度缓冲。大部分深度缓冲的精度都是24位的，但现在大部分的显卡都支持32位的深度缓冲，这将会极大地提高精度。所以，牺牲掉一些性能，你就能获得更高精度的深度测试，减少深度冲突。

我们上面讨论的三个技术是最普遍也是很容易实现的抗深度冲突技术了。还有一些更复杂的技术，但它们依然不能完全消除深度冲突。深度冲突是一个常见的问题，但如果你组合使用了上面列举出来的技术，你可能不会再需要处理深度冲突了。




## 模板测试
模板缓冲是否能做类似裁剪的功能
是的，模板缓冲区（Stencil Buffer）在OpenGL中可以用于实现类似裁剪的功能。实际上，模板缓冲区提供了一种非常灵活和强大的方法来限制渲染区域或应用复杂的遮罩，从而达到裁剪的效果。
下面是一些使用模板缓冲区进行“裁剪”操作的基本步骤：
1. **配置模板缓冲区**：初始化和清除模板缓冲区。
2. **创建裁剪区域**：利用模板缓冲区标记出将要被裁剪的区域。
3. **应用裁剪区域**：根据模板缓冲区中的标记来决定哪些片段应该被渲染。
### 示例代码
假设我们想在一个窗口中裁剪出一个圆形区域，只允许在该区域内进行绘制：
```cpp
#include <GL/glut.h>
#include <math.h>
void display() {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
    // 启用模板测试
    glEnable(GL_STENCIL_TEST);
    
    // 配置模板缓冲区，初始化为0
    glClearStencil(0);
    glClear(GL_STENCIL_BUFFER_BIT);
    // 第一步：在模板缓冲区中标记出圆形区域
    glStencilFunc(GL_ALWAYS, 1, 0xFF); // 总是通过模板测试
    glStencilOp(GL_REPLACE, GL_REPLACE, GL_REPLACE); // 设置模板缓冲区的值为1
    // 绘制一个覆盖整个窗口的圆形
    glBegin(GL_TRIANGLE_FAN);
    glVertex2f(0.0f, 0.0f);
    int numSegments = 100;
    float radius = 0.5f;
    for (int i = 0; i <= numSegments; ++i) {
        float angle = 2.0f * M_PI * float(i) / float(numSegments);
        float x = radius * cosf(angle);
        float y = radius * sinf(angle);
        glVertex2f(x, y);
    }
    glEnd();
    // 第二步：使用模板缓冲区进行裁剪
    glStencilFunc(GL_EQUAL, 1, 0xFF); // 仅当模板缓冲区的值为1时通过测试
    glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP); // 保持模板缓冲区的值不变
    // 在裁剪区域内绘制内容
    glColor3f(0.0, 1.0, 0.0);
    glBegin(GL_QUADS);
    glVertex2f(-0.75, -0.75);
    glVertex2f( 0.75, -0.75);
    glVertex2f( 0.75,  0.75);
    glVertex2f(-0.75,  0.75);
    glEnd();
    // 禁用模板测试
    glDisable(GL_STENCIL_TEST);
    glutSwapBuffers();
}
int main(int argc, char** argv) {
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH | GLUT_STENCIL);
    glutCreateWindow("Stencil Buffer Clipping Example");
    glutDisplayFunc(display);
    glutMainLoop();
    return 0;
}
```
在这个示例中，我们首先在模板缓冲区中标记出一个圆形区域，然后在该区域内进行绘制。具体步骤如下：
1. **启用模板测试并清除模板缓冲区**：
    - 使用 `glEnable(GL_STENCIL_TEST)` 启用模板测试。
    - 使用 `glClearStencil(0)` 和 `glClear(GL_STENCIL_BUFFER_BIT)` 清除模板缓冲区并初始化为0。
2. **标记裁剪区域**：
    - 通过设置 `glStencilFunc(GL_ALWAYS, 1, 0xFF)` 来确保所有片段都通过模板测试，并使用 `glStencilOp(GL_REPLACE, GL_REPLACE, GL_REPLACE)` 将模板缓冲区的对应值设置为1。
    - 然后绘制一个圆形，将模板缓冲区的对应位置标记为1。
3. **应用裁剪区域**：
    - 设置 `glStencilFunc(GL_EQUAL, 1, 0xFF)`，仅允许模板缓冲区值为1的片段通过，然后绘制内容。
4. **禁用模板测试**：
    - 使用 `glDisable(GL_STENCIL_TEST)` 禁用模板测试。
这种方式使用模板缓冲区实现了一个简单的圆形裁剪区域，当然，你可以根据需求绘制不同形状和复杂度的裁剪区域。



![alt text](image-64.png)
作为模板的先设置为always 然后


### 
模板加上深度
![alt text](image-65.png)

模板不加上深度
![alt text](image-66.png)

### 绘制一轮结束后，然后重置代码意义
在OpenGL中，当一轮绘制结束后，添加以下代码有助于重置和清理不同的状态，以便为下一轮绘制做好准备：
```cpp
glBindVertexArray(0);
glStencilMask(0xFF);
glStencilFunc(GL_ALWAYS, 0, 0xFF);
glEnable(GL_DEPTH_TEST);
```
让我们逐一分析这些操作：
1. `glBindVertexArray(0);`
   - 这行代码解除绑定当前的顶点数组对象（VAO）。解除绑定可以确保不会意外修改当前VAO，并且在下次绘制时从一个已知的状态开始。
2. `glStencilMask(0xFF);`
   - 设置模板掩码为全1（0xFF）。模板掩码控制哪个位可以在模板缓冲区中被写入。将它重置为0xFF表示可以写入所有位。这是一个重置操作，确保未来的绘制操作不会被之前设置的模板掩码限制。
3. `glStencilFunc(GL_ALWAYS, 0, 0xFF);`
   - 这个函数设置模板测试函数。当`GL_ALWAYS`被指定时，总是通过模板测试，新的模板值会被写入模板缓冲区。这样做确保以后的绘制操作不受之前可能设定的模板测试条件的影响。
4. `glEnable(GL_DEPTH_TEST);`
   - 启用深度测试，确保以后的绘制操作在深度缓冲区中进行正确的深度测试。如果深度测试之前被禁用，这行代码会重新启用它。
总结来说，这些操作的目的是为了确保每次绘制之前，OpenGL状态是重置到一个已知的、干净的状态。这可以避免各种潜在的问题，例如，前一轮绘制设置了某些状态，但是下一轮绘制没有显式地修改这些状态，从而导致不可预期的结果。通过重置关键的状态，可以确保每次绘制的结果都是可预见和可控的。




### 流程
一开始是模板缓冲清空为0的
![alt text](image-67.png)
先把原来的区域设置为1，然后开启模板缓冲填入，就把第一个模板冲刷为模板1的函数

在替换这边也很有讲究的
glStencilFunc(GL_NOTEQUAL, 1, 0xFF);
glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);
## 混合 blending
透明的部分就丢弃掉对应的片段即可就是实现透明的效果
片段着色器的 discard命令，一旦被调用该片段就不会继续被执行。
![alt text](image-68.png)
混色公式
简单来说就是自己的颜色所在的比例。
### blending 函数
glBlendFunc函数 正常是相加

glBlendEquation 函数 可以改变相减，和减的顺序

不过深度缓冲会导致后面的片段被舍弃掉
![alt text](image-69.png)
发生这一现象的原因是，深度测试和混合一起使用的话会产生一些麻烦。当写入深度缓冲时，深度缓冲不会检查片段是否是透明的，所以透明的部分会和其它值一样写入到深度缓冲中。结果就是窗户的整个四边形不论透明度都会进行深度测试。即使透明的部分应该显示背后的窗户，深度测试仍然丢弃了它们。

所以我们不能随意地决定如何渲染窗户，让深度缓冲解决所有的问题了。这也是混合变得有些麻烦的部分。要想保证窗户中能够显示它们背后的窗户，我们需要首先绘制背后的这部分窗户。这也就是说在绘制的时候，我们必须先手动将窗户按照最远到最近来排序，再按照顺序渲染。

注意，对于草这种全透明的物体，我们可以选择丢弃透明的片段而不是混合它们，这样就解决了这些头疼的问题（没有深度问题）。

解决方法：
通过一个map 记录他们的距离，和摄像机的距离，然后排序，从远到近进行绘制。


## 面剔除
### 作用：
 就是我们在一个时间里面，同时看到的一个正方体的面数 是不可能4面全的，有的特定角度只能一面，所以把看不到的不渲染，就可以提高渲染效率了。
### 解释：
这正是面剔除(Face Culling)所做的。OpenGL能够检查所有面向(Front Facing)观察者的面，并渲染它们，而丢弃那些背向(Back Facing)的面，节省我们很多的片段着色器调用（它们的开销很大！）。但我们仍要告诉OpenGL哪些面是正向面(Front Face)，哪些面是背向面(Back Face)。OpenGL使用了一个很聪明的技巧，分析顶点数据的环绕顺序(Winding Order)。

### 主要解决：
如何判断哪些面是面向用户，哪些是看不到的。


### 实现技巧：
利用环绕顺序技巧：
函数
当你定义顶点顺序的时候，你应该想象对应的三角形是面向你的，所以你定义的三角形从正面看去应该是逆时针的。这样定义顶点很棒的一点是，实际的环绕顺序是在光栅化阶段进行的，也就是顶点着色器运行之后。这些顶点就是从观察者视角所见的了。

### 实现函数
glEnable(GL_CULL_FACE);
glCullFace 剔除的可选项
GL_BACK：只剔除背向面。
GL_FRONT：只剔除正向面。
GL_FRONT_AND_BACK：剔除正向面和背向面。

## FBO framebufferObject 帧缓冲对象

